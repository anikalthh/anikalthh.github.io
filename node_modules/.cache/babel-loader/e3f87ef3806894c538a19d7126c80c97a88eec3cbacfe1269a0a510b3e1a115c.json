{"ast":null,"code":"// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = node => {\n  let parent = node;\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body) return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\") return parent;\n  }\n  return window;\n};\nvar isOffsetElement = el => el.firstChild ? el.firstChild.offsetParent === el : true;\nvar offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = node => {\n  let currentParent = node.parentElement;\n  while (currentParent) {\n    const style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\") break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\")) stickyProp = \"sticky\";else if (CSS.supports(\"position\", \"-webkit-sticky\")) stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  const opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = {\n        passive: true\n      };\n    }\n  });\n  const emptyHandler = () => {};\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {}\nvar getDimensions = opts => {\n  const {\n    el,\n    onChange,\n    unsubs,\n    measure\n  } = opts;\n  if (el === window) {\n    const getRect = () => ({\n      top: 0,\n      left: 0,\n      height: window.innerHeight,\n      width: window.innerWidth\n    });\n    const mResult = measure(getRect());\n    const handler = () => {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(() => window.addEventListener(\"resize\", handler, passiveArg));\n    return mResult;\n  } else {\n    const mResult = measure(el.getBoundingClientRect());\n    const handler = () => {\n      Object.assign(mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    const ro = new ResizeObserver(handler);\n    ro.observe(el);\n    unsubs.push(() => ro.disconnect());\n    return mResult;\n  }\n};\nvar getVerticalPadding = node => {\n  const computedParentStyle = getComputedStyle(node, null);\n  const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return {\n    top: parentPaddingTop,\n    bottom: parentPaddingBottom\n  };\n};\nvar setup = (node, unsubs, opts) => {\n  const {\n    bottom,\n    offsetBottom,\n    offsetTop\n  } = opts;\n  const scrollPane = getScrollParent(node);\n  let isScheduled = false;\n  const scheduleOnLayout = () => {\n    if (!isScheduled) {\n      requestAnimationFrame(() => {\n        const nextMode = onLayout();\n        if (nextMode !== mode) changeMode(nextMode);\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  const isBoxTooLow = scrollY => {\n    const {\n      offsetTop: scrollPaneOffset,\n      height: viewPortHeight\n    } = scrollPaneDims;\n    const {\n      naturalTop\n    } = parentDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  const onLayout = () => {\n    const {\n      height: viewPortHeight\n    } = scrollPaneDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n\n  const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  const scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: _ref => {\n      let {\n        height,\n        top\n      } = _ref;\n      return {\n        height,\n        offsetTop: scrollPaneIsOffsetEl ? top : 0\n      };\n    }\n  });\n  const parentNode = getParentNode(node);\n  const parentPaddings = parentNode === window ? {\n    top: 0,\n    bottom: 0\n  } : getVerticalPadding(parentNode);\n  const parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: _ref2 => {\n      let {\n        height\n      } = _ref2;\n      return {\n        height: height - parentPaddings.top - parentPaddings.bottom,\n        naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n      };\n    }\n  });\n  const nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: _ref3 => {\n      let {\n        height\n      } = _ref3;\n      return {\n        height\n      };\n    }\n  });\n  let relativeOffset = 0;\n  let mode = onLayout();\n  const changeMode = newMode => {\n    const prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */) relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = `${offsetBottom}px`;\n      } else {\n        node.style.top = `${offsetTop}px`;\n      }\n      return;\n    }\n    const {\n      height: viewPortHeight,\n      offsetTop: scrollPaneOffset\n    } = scrollPaneDims;\n    const {\n      height: parentHeight,\n      naturalTop\n    } = parentDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n      if (bottom) {\n        const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = `${nextBottom}px`;\n      } else {\n        node.style.top = `${relativeOffset}px`;\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = `${offsetBottom}px`;\n        } else {\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else {\n          node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  const onScroll = scrollY => {\n    if (scrollY === latestScrollY) return;\n    const scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */) return;\n    const {\n      offsetTop: scrollPaneOffset,\n      height: viewPortHeight\n    } = scrollPaneDims;\n    const {\n      naturalTop,\n      height: parentHeight\n    } = parentDims;\n    const {\n      height: nodeHeight\n    } = nodeDims;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY)) changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          const bottomOffset = Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n\n  const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(() => scrollPane.removeEventListener(\"scroll\", handleScroll), () => scrollPane.removeEventListener(\"mousewheel\", handleScroll));\n};\nvar useStickyBox = function () {\n  let {\n    offsetTop = 0,\n    offsetBottom = 0,\n    bottom = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [node, setNode] = useState(null);\n  useEffect(() => {\n    if (!node || !stickyProp) return;\n    const unsubs = [];\n    setup(node, unsubs, {\n      offsetBottom,\n      offsetTop,\n      bottom\n    });\n    return () => {\n      unsubs.forEach(fn => fn());\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = props => {\n  const {\n    offsetTop,\n    offsetBottom,\n    bottom,\n    children,\n    className,\n    style\n  } = props;\n  const ref = useStickyBox({\n    offsetTop,\n    offsetBottom,\n    bottom\n  });\n  return /* @__PURE__ */jsx(\"div\", {\n    className,\n    style,\n    ref,\n    children\n  });\n};\nvar src_default = StickyBox;\nexport { src_default as default, useStickyBox };","map":{"version":3,"names":["useEffect","useState","jsx","getScrollParent","node","parent","parentElement","overflowYVal","getComputedStyle","getPropertyValue","document","body","window","isOffsetElement","el","firstChild","offsetParent","offsetTill","target","current","offset","offsetTop","getParentNode","currentParent","style","stickyProp","CSS","supports","passiveArg","opts","Object","defineProperty","get","passive","emptyHandler","addEventListener","removeEventListener","e","getDimensions","onChange","unsubs","measure","getRect","top","left","height","innerHeight","width","innerWidth","mResult","handler","assign","push","getBoundingClientRect","ro","ResizeObserver","observe","disconnect","getVerticalPadding","computedParentStyle","parentPaddingTop","parseInt","parentPaddingBottom","bottom","setup","offsetBottom","scrollPane","isScheduled","scheduleOnLayout","requestAnimationFrame","nextMode","onLayout","mode","changeMode","latestScrollY","scrollY","scrollTop","isBoxTooLow","scrollPaneOffset","viewPortHeight","scrollPaneDims","naturalTop","parentDims","nodeHeight","nodeDims","relativeOffset","scrollPaneIsOffsetEl","parentNode","parentPaddings","newMode","prevMode","position","parentHeight","Math","max","nextBottom","onScroll","scrollDelta","topOffset","bottomOffset","handleScroll","useStickyBox","setNode","forEach","fn","StickyBox","props","children","className","ref","src_default","default"],"sources":["/Users/admin/my-react-portfolio-1/node_modules/react-sticky-box/dist/index.js"],"sourcesContent":["// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = (node) => {\n  let parent = node;\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body)\n      return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\")\n      return parent;\n  }\n  return window;\n};\nvar isOffsetElement = (el) => el.firstChild ? el.firstChild.offsetParent === el : true;\nvar offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = (node) => {\n  let currentParent = node.parentElement;\n  while (currentParent) {\n    const style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\")\n      break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\"))\n    stickyProp = \"sticky\";\n  else if (CSS.supports(\"position\", \"-webkit-sticky\"))\n    stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  const opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = { passive: true };\n    }\n  });\n  const emptyHandler = () => {\n  };\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {\n}\nvar getDimensions = (opts) => {\n  const { el, onChange, unsubs, measure } = opts;\n  if (el === window) {\n    const getRect = () => ({ top: 0, left: 0, height: window.innerHeight, width: window.innerWidth });\n    const mResult = measure(getRect());\n    const handler = () => {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(() => window.addEventListener(\"resize\", handler, passiveArg));\n    return mResult;\n  } else {\n    const mResult = measure(el.getBoundingClientRect());\n    const handler = () => {\n      Object.assign(mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    const ro = new ResizeObserver(handler);\n    ro.observe(el);\n    unsubs.push(() => ro.disconnect());\n    return mResult;\n  }\n};\nvar getVerticalPadding = (node) => {\n  const computedParentStyle = getComputedStyle(node, null);\n  const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return { top: parentPaddingTop, bottom: parentPaddingBottom };\n};\nvar setup = (node, unsubs, opts) => {\n  const { bottom, offsetBottom, offsetTop } = opts;\n  const scrollPane = getScrollParent(node);\n  let isScheduled = false;\n  const scheduleOnLayout = () => {\n    if (!isScheduled) {\n      requestAnimationFrame(() => {\n        const nextMode = onLayout();\n        if (nextMode !== mode)\n          changeMode(nextMode);\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  const isBoxTooLow = (scrollY) => {\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  const onLayout = () => {\n    const { height: viewPortHeight } = scrollPaneDims;\n    const { height: nodeHeight } = nodeDims;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n  const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  const scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height, top }) => ({\n      height,\n      offsetTop: scrollPaneIsOffsetEl ? top : 0\n    })\n  });\n  const parentNode = getParentNode(node);\n  const parentPaddings = parentNode === window ? { top: 0, bottom: 0 } : getVerticalPadding(parentNode);\n  const parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({\n      height: height - parentPaddings.top - parentPaddings.bottom,\n      naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n    })\n  });\n  const nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({ height })\n  });\n  let relativeOffset = 0;\n  let mode = onLayout();\n  const changeMode = (newMode) => {\n    const prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */)\n      relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = `${offsetBottom}px`;\n      } else {\n        node.style.top = `${offsetTop}px`;\n      }\n      return;\n    }\n    const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;\n    const { height: parentHeight, naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(\n        0,\n        scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n      );\n      if (bottom) {\n        const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = `${nextBottom}px`;\n      } else {\n        node.style.top = `${relativeOffset}px`;\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = `${offsetBottom}px`;\n        } else {\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else {\n          node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  const onScroll = (scrollY) => {\n    if (scrollY === latestScrollY)\n      return;\n    const scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */)\n      return;\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop, height: parentHeight } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY))\n          changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          const bottomOffset = Math.max(\n            0,\n            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n          );\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n  const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(\n    () => scrollPane.removeEventListener(\"scroll\", handleScroll),\n    () => scrollPane.removeEventListener(\"mousewheel\", handleScroll)\n  );\n};\nvar useStickyBox = ({\n  offsetTop = 0,\n  offsetBottom = 0,\n  bottom = false\n} = {}) => {\n  const [node, setNode] = useState(null);\n  useEffect(() => {\n    if (!node || !stickyProp)\n      return;\n    const unsubs = [];\n    setup(node, unsubs, { offsetBottom, offsetTop, bottom });\n    return () => {\n      unsubs.forEach((fn) => fn());\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = (props) => {\n  const { offsetTop, offsetBottom, bottom, children, className, style } = props;\n  const ref = useStickyBox({ offsetTop, offsetBottom, bottom });\n  return /* @__PURE__ */ jsx(\"div\", { className, style, ref, children });\n};\nvar src_default = StickyBox;\nexport {\n  src_default as default,\n  useStickyBox\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}