{"ast":null,"code":"import _slicedToArray from \"/Users/admin/Documents/GitHub/anikalthh.github.io/my-react-portfolio-1/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = function getScrollParent(node) {\n  var parent = node;\n  while (parent = parent.parentElement) {\n    var overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body) return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\") return parent;\n  }\n  return window;\n};\nvar isOffsetElement = function isOffsetElement(el) {\n  return el.firstChild ? el.firstChild.offsetParent === el : true;\n};\nvar offsetTill = function offsetTill(node, target) {\n  var current = node;\n  var offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = function getParentNode(node) {\n  var currentParent = node.parentElement;\n  while (currentParent) {\n    var style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\") break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\")) stickyProp = \"sticky\";else if (CSS.supports(\"position\", \"-webkit-sticky\")) stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  var opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get: function get() {\n      passiveArg = {\n        passive: true\n      };\n    }\n  });\n  var emptyHandler = function emptyHandler() {};\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {}\nvar getDimensions = function getDimensions(opts) {\n  var el = opts.el,\n    onChange = opts.onChange,\n    unsubs = opts.unsubs,\n    measure = opts.measure;\n  if (el === window) {\n    var getRect = function getRect() {\n      return {\n        top: 0,\n        left: 0,\n        height: window.innerHeight,\n        width: window.innerWidth\n      };\n    };\n    var mResult = measure(getRect());\n    var handler = function handler() {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(function () {\n      return window.addEventListener(\"resize\", handler, passiveArg);\n    });\n    return mResult;\n  } else {\n    var _mResult = measure(el.getBoundingClientRect());\n    var _handler = function _handler() {\n      Object.assign(_mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    var ro = new ResizeObserver(_handler);\n    ro.observe(el);\n    unsubs.push(function () {\n      return ro.disconnect();\n    });\n    return _mResult;\n  }\n};\nvar getVerticalPadding = function getVerticalPadding(node) {\n  var computedParentStyle = getComputedStyle(node, null);\n  var parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  var parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return {\n    top: parentPaddingTop,\n    bottom: parentPaddingBottom\n  };\n};\nvar setup = function setup(node, unsubs, opts) {\n  var bottom = opts.bottom,\n    offsetBottom = opts.offsetBottom,\n    offsetTop = opts.offsetTop;\n  var scrollPane = getScrollParent(node);\n  var isScheduled = false;\n  var scheduleOnLayout = function scheduleOnLayout() {\n    if (!isScheduled) {\n      requestAnimationFrame(function () {\n        var nextMode = onLayout();\n        if (nextMode !== mode) changeMode(nextMode);\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  var latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  var isBoxTooLow = function isBoxTooLow(scrollY) {\n    var scrollPaneOffset = scrollPaneDims.offsetTop,\n      viewPortHeight = scrollPaneDims.height;\n    var naturalTop = parentDims.naturalTop;\n    var nodeHeight = nodeDims.height;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  var onLayout = function onLayout() {\n    var viewPortHeight = scrollPaneDims.height;\n    var nodeHeight = nodeDims.height;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n\n  var scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  var scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs: unsubs,\n    measure: function measure(_ref) {\n      var height = _ref.height,\n        top = _ref.top;\n      return {\n        height: height,\n        offsetTop: scrollPaneIsOffsetEl ? top : 0\n      };\n    }\n  });\n  var parentNode = getParentNode(node);\n  var parentPaddings = parentNode === window ? {\n    top: 0,\n    bottom: 0\n  } : getVerticalPadding(parentNode);\n  var parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs: unsubs,\n    measure: function measure(_ref2) {\n      var height = _ref2.height;\n      return {\n        height: height - parentPaddings.top - parentPaddings.bottom,\n        naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n      };\n    }\n  });\n  var nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs: unsubs,\n    measure: function measure(_ref3) {\n      var height = _ref3.height;\n      return {\n        height: height\n      };\n    }\n  });\n  var relativeOffset = 0;\n  var mode = onLayout();\n  var changeMode = function changeMode(newMode) {\n    var prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */) relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = \"\".concat(offsetBottom, \"px\");\n      } else {\n        node.style.top = \"\".concat(offsetTop, \"px\");\n      }\n      return;\n    }\n    var viewPortHeight = scrollPaneDims.height,\n      scrollPaneOffset = scrollPaneDims.offsetTop;\n    var parentHeight = parentDims.height,\n      naturalTop = parentDims.naturalTop;\n    var nodeHeight = nodeDims.height;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n      if (bottom) {\n        var nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = \"\".concat(nextBottom, \"px\");\n      } else {\n        node.style.top = \"\".concat(relativeOffset, \"px\");\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = \"\".concat(offsetBottom, \"px\");\n        } else {\n          node.style.top = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = \"\".concat(viewPortHeight - nodeHeight - offsetBottom, \"px\");\n        } else {\n          node.style.top = \"\".concat(offsetTop, \"px\");\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  var onScroll = function onScroll(scrollY) {\n    if (scrollY === latestScrollY) return;\n    var scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */) return;\n    var scrollPaneOffset = scrollPaneDims.offsetTop,\n      viewPortHeight = scrollPaneDims.height;\n    var naturalTop = parentDims.naturalTop,\n      parentHeight = parentDims.height;\n    var nodeHeight = nodeDims.height;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          var topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY)) changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          var bottomOffset = Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n\n  var handleScroll = scrollPane === window ? function () {\n    return onScroll(window.scrollY);\n  } : function () {\n    return onScroll(scrollPane.scrollTop);\n  };\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(function () {\n    return scrollPane.removeEventListener(\"scroll\", handleScroll);\n  }, function () {\n    return scrollPane.removeEventListener(\"mousewheel\", handleScroll);\n  });\n};\nvar useStickyBox = function useStickyBox() {\n  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref4$offsetTop = _ref4.offsetTop,\n    offsetTop = _ref4$offsetTop === void 0 ? 0 : _ref4$offsetTop,\n    _ref4$offsetBottom = _ref4.offsetBottom,\n    offsetBottom = _ref4$offsetBottom === void 0 ? 0 : _ref4$offsetBottom,\n    _ref4$bottom = _ref4.bottom,\n    bottom = _ref4$bottom === void 0 ? false : _ref4$bottom;\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    node = _useState2[0],\n    setNode = _useState2[1];\n  useEffect(function () {\n    if (!node || !stickyProp) return;\n    var unsubs = [];\n    setup(node, unsubs, {\n      offsetBottom: offsetBottom,\n      offsetTop: offsetTop,\n      bottom: bottom\n    });\n    return function () {\n      unsubs.forEach(function (fn) {\n        return fn();\n      });\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = function StickyBox(props) {\n  var offsetTop = props.offsetTop,\n    offsetBottom = props.offsetBottom,\n    bottom = props.bottom,\n    children = props.children,\n    className = props.className,\n    style = props.style;\n  var ref = useStickyBox({\n    offsetTop: offsetTop,\n    offsetBottom: offsetBottom,\n    bottom: bottom\n  });\n  return /* @__PURE__ */jsx(\"div\", {\n    className: className,\n    style: style,\n    ref: ref,\n    children: children\n  });\n};\nvar src_default = StickyBox;\nexport { src_default as default, useStickyBox };","map":{"version":3,"names":["useEffect","useState","jsx","getScrollParent","node","parent","parentElement","overflowYVal","getComputedStyle","getPropertyValue","document","body","window","isOffsetElement","el","firstChild","offsetParent","offsetTill","target","current","offset","offsetTop","getParentNode","currentParent","style","stickyProp","CSS","supports","passiveArg","opts","Object","defineProperty","get","passive","emptyHandler","addEventListener","removeEventListener","e","getDimensions","onChange","unsubs","measure","getRect","top","left","height","innerHeight","width","innerWidth","mResult","handler","assign","push","getBoundingClientRect","ro","ResizeObserver","observe","disconnect","getVerticalPadding","computedParentStyle","parentPaddingTop","parseInt","parentPaddingBottom","bottom","setup","offsetBottom","scrollPane","isScheduled","scheduleOnLayout","requestAnimationFrame","nextMode","onLayout","mode","changeMode","latestScrollY","scrollY","scrollTop","isBoxTooLow","scrollPaneOffset","scrollPaneDims","viewPortHeight","naturalTop","parentDims","nodeHeight","nodeDims","relativeOffset","scrollPaneIsOffsetEl","parentNode","parentPaddings","newMode","prevMode","position","parentHeight","Math","max","nextBottom","onScroll","scrollDelta","topOffset","bottomOffset","handleScroll","useStickyBox","setNode","forEach","fn","StickyBox","props","children","className","ref","src_default","default"],"sources":["/Users/admin/Documents/GitHub/anikalthh.github.io/my-react-portfolio-1/node_modules/react-sticky-box/dist/index.js"],"sourcesContent":["// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = (node) => {\n  let parent = node;\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body)\n      return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\")\n      return parent;\n  }\n  return window;\n};\nvar isOffsetElement = (el) => el.firstChild ? el.firstChild.offsetParent === el : true;\nvar offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = (node) => {\n  let currentParent = node.parentElement;\n  while (currentParent) {\n    const style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\")\n      break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\"))\n    stickyProp = \"sticky\";\n  else if (CSS.supports(\"position\", \"-webkit-sticky\"))\n    stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  const opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = { passive: true };\n    }\n  });\n  const emptyHandler = () => {\n  };\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {\n}\nvar getDimensions = (opts) => {\n  const { el, onChange, unsubs, measure } = opts;\n  if (el === window) {\n    const getRect = () => ({ top: 0, left: 0, height: window.innerHeight, width: window.innerWidth });\n    const mResult = measure(getRect());\n    const handler = () => {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(() => window.addEventListener(\"resize\", handler, passiveArg));\n    return mResult;\n  } else {\n    const mResult = measure(el.getBoundingClientRect());\n    const handler = () => {\n      Object.assign(mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    const ro = new ResizeObserver(handler);\n    ro.observe(el);\n    unsubs.push(() => ro.disconnect());\n    return mResult;\n  }\n};\nvar getVerticalPadding = (node) => {\n  const computedParentStyle = getComputedStyle(node, null);\n  const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return { top: parentPaddingTop, bottom: parentPaddingBottom };\n};\nvar setup = (node, unsubs, opts) => {\n  const { bottom, offsetBottom, offsetTop } = opts;\n  const scrollPane = getScrollParent(node);\n  let isScheduled = false;\n  const scheduleOnLayout = () => {\n    if (!isScheduled) {\n      requestAnimationFrame(() => {\n        const nextMode = onLayout();\n        if (nextMode !== mode)\n          changeMode(nextMode);\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  const isBoxTooLow = (scrollY) => {\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  const onLayout = () => {\n    const { height: viewPortHeight } = scrollPaneDims;\n    const { height: nodeHeight } = nodeDims;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n  const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  const scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height, top }) => ({\n      height,\n      offsetTop: scrollPaneIsOffsetEl ? top : 0\n    })\n  });\n  const parentNode = getParentNode(node);\n  const parentPaddings = parentNode === window ? { top: 0, bottom: 0 } : getVerticalPadding(parentNode);\n  const parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({\n      height: height - parentPaddings.top - parentPaddings.bottom,\n      naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n    })\n  });\n  const nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({ height })\n  });\n  let relativeOffset = 0;\n  let mode = onLayout();\n  const changeMode = (newMode) => {\n    const prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */)\n      relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = `${offsetBottom}px`;\n      } else {\n        node.style.top = `${offsetTop}px`;\n      }\n      return;\n    }\n    const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;\n    const { height: parentHeight, naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(\n        0,\n        scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n      );\n      if (bottom) {\n        const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = `${nextBottom}px`;\n      } else {\n        node.style.top = `${relativeOffset}px`;\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = `${offsetBottom}px`;\n        } else {\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else {\n          node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  const onScroll = (scrollY) => {\n    if (scrollY === latestScrollY)\n      return;\n    const scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */)\n      return;\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop, height: parentHeight } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY))\n          changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          const bottomOffset = Math.max(\n            0,\n            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n          );\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n  const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(\n    () => scrollPane.removeEventListener(\"scroll\", handleScroll),\n    () => scrollPane.removeEventListener(\"mousewheel\", handleScroll)\n  );\n};\nvar useStickyBox = ({\n  offsetTop = 0,\n  offsetBottom = 0,\n  bottom = false\n} = {}) => {\n  const [node, setNode] = useState(null);\n  useEffect(() => {\n    if (!node || !stickyProp)\n      return;\n    const unsubs = [];\n    setup(node, unsubs, { offsetBottom, offsetTop, bottom });\n    return () => {\n      unsubs.forEach((fn) => fn());\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = (props) => {\n  const { offsetTop, offsetBottom, bottom, children, className, style } = props;\n  const ref = useStickyBox({ offsetTop, offsetBottom, bottom });\n  return /* @__PURE__ */ jsx(\"div\", { className, style, ref, children });\n};\nvar src_default = StickyBox;\nexport {\n  src_default as default,\n  useStickyBox\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}